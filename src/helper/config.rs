// Some Config File Stuff

use dirs_next;
use mlua::Lua;
use std::fs;
use std::path::PathBuf;

use crate::helper::exit;

// flua Config struct
pub struct FluaConfig {
    // CONFIG VALUES
    pub wait_time: u64,
    pub show_info: bool,
}

// Function to load the Config File
pub fn loadconfig(doload: bool) -> FluaConfig {
    if !doload {
        return FluaConfig {
            wait_time: 3,
            show_info: true,
        };
    }

    let mut path: PathBuf = dirs_next::config_dir().expect("could not find config_dir()");

    path.push("@shadowdara");
    path.push("flua");
    path.push("config.lua");

    let contents: String = match fs::read_to_string(&path) {
        Ok(c) => c,
        Err(_) => {
            println!("Config file not found, using default Config.");
            return FluaConfig {
                wait_time: 3,
                show_info: true,
            };
        }
    };

    let lua = Lua::new();

    // Lua ausf√ºhren
    lua.load(contents).exec().expect("Failed to exec Lua");

    // Jetzt aus Rust die Lua-Tabelle auslesen
    let globals = lua.globals();
    let config_table = globals.get::<mlua::Table>("c").expect("No 'c' table found");

    let wait_time: u64 = config_table.get("wait_time").unwrap_or(3);
    let show_info: bool = config_table.get("wait_time").unwrap_or(true);

    return FluaConfig {
        wait_time,
        show_info,
    };
}

pub fn configstuff(args: Vec<String>, wait_on_exit: bool) {
    let mut args_iter = args.iter().peekable();
    let mut path: PathBuf = dirs_next::config_dir().expect("could not find config_dir()");

    path.push("@shadowdara");
    path.push("flua");
    path.push("config.lua");

    match args_iter.peek().map(|s| s.as_str()) {
        // To generate a new Config File
        Some("generate") => {
            println!("Generating new config file...");

            if path.exists() {
                println!(
                    "Config file already exists at '{}', skipping creation.",
                    path.display()
                );
            } else {
                let contents = r#"-- DO NOT EDIT THIS FILE IF YOU DONT NOW WHAT YOU ARE DOING !!!
--
-- Configfile for Flua
--
-- More Infos available here
-- https://github.com/ShadowDara/LuaAPI-Rust
-- https://shadowdara.github.io/flua/

-- Variable for Config Values
c = {}

-- Varibales for the close / error wait time
c.wait_time = 0

-- Setting for Info printing in the Terminal
c.show_info = false
"#;

                match fs::write(path.clone(), contents) {
                    Ok(_) => println!("File '{}' created!", path.display()),
                    Err(e) => eprintln!("Error while creating file: {}", e),
                }
            }
        }
        // to delete the config file
        Some("clean") => match fs::remove_file(path.clone()) {
            Ok(_) => println!("==> Configfile '{}' deleted!", path.display()),
            Err(e) => println!("==> Error while deleting: {}", e),
        },
        // To open the Config File in a default Editor
        Some("open") => {
            // args_iter.next(); // consume the "open" argument
            println!("Opening config file...");
            open::that(&path).expect("Failed to open file");
            // Open code here
        }
        Some("opendir") => {
            // Open the directory of the config file
            path.pop();
            open::that(path).expect("Could not open config Folder");
        }
        Some("dir") => {
            // Show the directory of the config file
            path.pop();
            println!("Config Folder: {}", path.display());
        }
        Some("check") => {
            // Trying to load the config file if it works
            println!("Config Check Implemented soon!\nPlease open an Issue on GitHub if you see this!");
        }
        _ => {
            println!("No subcommand specified for config.");
            println!("or run flua --help-config")
        }
    }
    // Interrupt after opening the Config File
    exit(wait_on_exit, false);
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn loadconfig_returns_defaults_when_disabled() {
        let cfg = loadconfig(false);
        assert_eq!(cfg.wait_time, 3);
        assert!(cfg.show_info);
    }

    // // TODO
    // // Problem:
    // // The Test loads the normal Config file on the System
    // #[test]
    // fn loadconfig_returns_defaults_if_file_missing() {
    //     let dir = tempdir().unwrap();
    //     unsafe {
    //         std::env::set_var("XDG_CONFIG_HOME", dir.path());
    //     }

    //     let cfg = loadconfig(true);
    //     assert_eq!(cfg.wait_time, 3);
    //     assert!(cfg.show_info);
    // }

    // // TODO
    // // Problem:
    // // The Test loads the normal Config file on the System
    // #[test]
    // fn loadconfig_reads_values_from_lua_file() {
    //     let dir = tempdir().unwrap();
    //     unsafe {
    //         std::env::set_var("XDG_CONFIG_HOME", dir.path());
    //     }

    //     let config_dir = dir.path().join("flua");
    //     fs::create_dir_all(&config_dir).unwrap();
    //     let config_path = config_dir.join("config.lua");

    //     let lua_content = r#"
    //     c = {}
    //     c.wait_time = 42
    //     c.show_info = false
    // "#;
    //     fs::write(&config_path, lua_content).unwrap();

    //     let cfg = loadconfig(true);
    //     assert_eq!(cfg.wait_time, 42);
    //     assert_eq!(cfg.show_info, false);
    // }

    #[test]
    fn configstuff_generate_creates_file() {
        let dir = tempdir().unwrap();
        unsafe {
            std::env::set_var("XDG_CONFIG_HOME", dir.path());
        }

        let args = vec![String::from("generate")];

        configstuff(args, false);

        let config_path = dir.path().join("@shadowdara/flua/config.lua");
        assert!(
            config_path.exists(),
            "Config file should exist after generate"
        );
    }

    #[test]
    fn configstuff_clean_deletes_file() {
        let dir = tempdir().unwrap();
        unsafe {
            std::env::set_var("XDG_CONFIG_HOME", dir.path());
        }

        let config_dir = dir.path().join("@shadowdara/flua");
        fs::create_dir_all(&config_dir).unwrap();
        let config_path = config_dir.join("config.lua");

        fs::write(&config_path, "test").unwrap();
        assert!(config_path.exists());

        let args = vec![String::from("clean")];

        configstuff(args, false);
        assert!(
            !config_path.exists(),
            "Config file should be deleted by 'clean'"
        );
    }

    #[test]
    fn configstuff_open_does_not_panic() {
        let dir = tempdir().unwrap();
        unsafe {
            std::env::set_var("XDG_CONFIG_HOME", dir.path());
        }

        let args = vec![String::from("open")];

        let _ = std::panic::catch_unwind(|| configstuff(args, false));
    }

    #[test]
    fn configstuff_no_argument_prints_message() {
        let dir = tempdir().unwrap();
        unsafe {
            std::env::set_var("XDG_CONFIG_HOME", dir.path());
        }

        let args: Vec<String> = vec![];

        configstuff(args, false);
    }

    // // TODO
    // // Problem:
    // // The Test loads the normal Config file on the System
    // #[test]
    // fn loadconfig_returns_default_on_invalid_lua() {
    //     let dir = tempdir().unwrap();
    //     unsafe {
    //         std::env::set_var("XDG_CONFIG_HOME", dir.path());
    //     }

    //     let config_dir = dir.path().join("@shadowdara/flua");
    //     fs::create_dir_all(&config_dir).unwrap();
    //     fs::write(config_dir.join("config.lua"), "this is not lua").unwrap();

    //     let c = loadconfig(true);
    //     assert_eq!(c.wait_time, 3);
    //     assert_eq!(c.show_info, true);
    // }
}
