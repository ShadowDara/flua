// Some Config File Stuff

use dirs_next;
use mlua::Lua;
use std::fs;
use std::iter::Peekable;
use std::path::PathBuf;

use crate::helper::exit;

// flua Config struct
pub struct FluaConfig {
    // CONFIG VALUES
    pub wait_time: u64,
    pub show_info: bool
}

// Function to load the Config File
pub fn loadconfig(doload: bool) -> FluaConfig {
    if !doload {
        return FluaConfig { wait_time: 3, show_info: true };
    }

    let mut path: PathBuf = dirs_next::config_dir().expect("could not find config_dir()");

    path.push("@shadowdara");
    path.push("flua");
    path.push("config.lua");

    let contents: String = match fs::read_to_string(&path) {
        Ok(c) => c,
        Err(_) => {
            println!("Config file not found, using default Config.");
            return FluaConfig { wait_time: 3, show_info: true };
        }
    };

    let lua = Lua::new();

    // Lua ausf√ºhren
    lua.load(contents).exec().expect("Failed to exec Lua");

    // Jetzt aus Rust die Lua-Tabelle auslesen
    let globals = lua.globals();
    let config_table = globals
        .get::<mlua::Table>("c")
        .expect("No 'c' table found");

    let wait_time: u64 = config_table.get("wait_time").unwrap_or(0);
    let show_info: bool = config_table.get("wait_time").unwrap_or(true);
    
    return FluaConfig { wait_time, show_info }
}

pub fn configstuff(
    mut args_iter: Peekable<std::slice::Iter<'_, std::string::String>>,
    wait_on_exit: bool,
) {
    let mut path: PathBuf = dirs_next::config_dir().expect("could not find config_dir()");

    path.push("@shadowdara");
    path.push("flua");
    path.push("config.lua");

    match args_iter.peek().map(|s| s.as_str()) {
        // To generate a new Config File
        Some("generate") => {
            println!("Generating new config file...");

            if path.exists() {
                println!(
                    "Config file already exists at '{}', skipping creation.",
                    path.display()
                );
            } else {
                let contents = r#"-- DO NOT EDIT THIS FILE IF YOU DONT NOW WHAT YOU ARE DOING !!!
--
-- Configfile for Flua
--
-- More Infos available here
-- https://github.com/ShadowDara/LuaAPI-Rust
-- https://shadowdara.github.io/flua/

-- Variable for Config Values
c = {}

-- Varibales for the close / error wait time
c.wait_time = 0

-- Setting for Info printing in the Terminal
c.show_info = false
"#;

                match fs::write(path.clone(), contents) {
                    Ok(_) => println!("File '{}' created!", path.display()),
                    Err(e) => eprintln!("Error while creating file: {}", e),
                }
            }
        }
        // to delete the config file
        Some("clean") => match fs::remove_file(path.clone()) {
            Ok(_) => println!("==> Configfile '{}' deleted!", path.display()),
            Err(e) => println!("==> Error while deleting: {}", e),
        },
        // To open the Config File in a default Editor
        Some("open") => {
            // args_iter.next(); // consume the "open" argument
            println!("Opening config file...");
            open::that(&path).expect("Failed to open file");
            // Open code here
        }
        Some("opendir") => {
            // Open the directory of the config file
            println!("Implemented soon!");
        }
        Some("check") => {
            // Trying to load the config file if it works
            println!("Implemented soon!");
        }
        _ => {
            println!("No subcommand specified for config.");
        }
    }
    // Interrupt after opening the Config File
    exit(wait_on_exit, false);
}
